name: Auto Release & Deep Changelog

on:
  push:
    branches: [ "master", "main" ]
    paths: [ "pom.xml" ]
  workflow_dispatch:

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 
          lfs: true

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'

      - name: Install Local Dependencies
        run: |
          # Ensure this path matches your repo structure
          if [ -f "libs/PaperSpigot-1.8.8-R0.1-SNAPSHOT.jar" ]; then
            mvn install:install-file \
              -Dfile=libs/PaperSpigot-1.8.8-R0.1-SNAPSHOT.jar \
              -DgroupId=org.github.paperspigot \
              -DartifactId=paperspigot-api \
              -Dversion=1.8.8-R0.1-SNAPSHOT \
              -Dpackaging=jar \
              -DgeneratePom=true
          else
            echo "Warning: Local dependency not found, skipping install."
          fi

      - name: Check Version & Tag
        id: check_version
        run: |
          NEW_VERSION=$(mvn -N help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "Detected version: $NEW_VERSION"
          
          if git rev-parse "v${NEW_VERSION}" >/dev/null 2>&1; then
            echo "Tag v${NEW_VERSION} already exists."
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "New version detected."
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            
            # Find the previous tag to calculate the range
            PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Build Project
        if: steps.check_version.outputs.changed == 'true'
        run: mvn -B clean package --file pom.xml

      - name: Generate Deep Changelog
        if: steps.check_version.outputs.changed == 'true'
        id: changelog
        shell: bash
        run: |
          PREV_TAG="${{ steps.check_version.outputs.previous_tag }}"
          
          if [ -z "$PREV_TAG" ]; then
            RANGE="HEAD"
            echo "No previous tag. Analyzing all history."
          else
            RANGE="${PREV_TAG}..HEAD"
            echo "Analyzing range: $RANGE"
          fi

          # 1. Extract raw commit data (Subject + Body) into a temp file
          # %s = Subject, %b = Body, separated by a unique delimiter
          git log $RANGE --pretty=format:"%s%n%b%n---COMMIT_DELIMITER---%n" > raw_commits.txt

          # Prepare output files
          touch features.txt fixes.txt improvements.txt other.txt

          # 2. Python script to parse the raw text and unpack squash merges
          python3 -c '
          import re

          def categorize(line):
              lower = line.lower().strip()
              # Remove common list markers like "* ", "- ", "1. "
              clean_line = re.sub(r"^[\*\-]\s+", "", line).strip()
              
              if not clean_line: return

              if any(x in lower for x in ["fix", "bug", "issue", "crash", "resolve", "patch"]):
                  with open("fixes.txt", "a") as f: f.write(f"- {clean_line}\n")
              elif any(x in lower for x in ["add", "new", "feat", "implement", "create"]):
                  with open("features.txt", "a") as f: f.write(f"- {clean_line}\n")
              elif any(x in lower for x in ["update", "improve", "enhance", "refactor", "optimiz", "adjust"]):
                  with open("improvements.txt", "a") as f: f.write(f"- {clean_line}\n")
              else:
                  with open("other.txt", "a") as f: f.write(f"- {clean_line}\n")

          with open("raw_commits.txt", "r") as f:
              content = f.read()

          commits = content.split("---COMMIT_DELIMITER---")

          for commit in commits:
              if not commit.strip(): continue
              
              lines = commit.strip().split("\n")
              subject = lines[0]
              body = lines[1:] if len(lines) > 1 else []

              # Check if body contains asterisk list (indicative of squash merge)
              squash_lines = [line for line in body if line.strip().startswith("* ") or line.strip().startswith("- ")]

              if squash_lines:
                  # This is a squash merge, process the inner lines
                  for line in squash_lines:
                      categorize(line)
              else:
                  # Regular commit, process the subject
                  # Ignore Merge commits that are not squashed lists
                  if not subject.lower().startswith("merge"):
                      categorize(subject)
          '

          # 3. Assemble the Final Markdown
          BODY=""

          if [ -s features.txt ]; then
            BODY="${BODY}### ‚ú® New Features\n$(cat features.txt)\n"
          fi
          if [ -s fixes.txt ]; then
            BODY="${BODY}### üêõ Bug Fixes\n$(cat fixes.txt)\n"
          fi
          if [ -s improvements.txt ]; then
            BODY="${BODY}### üöÄ Improvements\n$(cat improvements.txt)\n"
          fi
          if [ -s other.txt ]; then
            BODY="${BODY}### üîß Other Changes\n$(cat other.txt)\n"
          fi

          if [ -z "$BODY" ]; then
            BODY="No significant changes found."
          fi

          # Export to GitHub Output (Multi-line safe)
          {
            echo 'body<<EOF'
            echo -e "$BODY"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Publish Release
        if: steps.check_version.outputs.changed == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.check_version.outputs.version }}
          name: ZonePractice Pro v${{ steps.check_version.outputs.version }}
          body: ${{ steps.changelog.outputs.body }}
          draft: false
          prerelease: false
          files: |
            distribution/target/*.jar
            !distribution/target/original-*.jar
